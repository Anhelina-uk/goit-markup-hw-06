# goit-markup-hw-01

**Важливі ссилкі**
Google Fonts:
https://fonts.google.com

Валідатор коду:
https://validator.w3.org

Нормалізатор стилів:
https://cdnjs.com/libraries/modern-normalize/0.1.0
https://github.com/sindresorhus/modern-normalize

Український веб-довідник по HTML і CSS:
https://css.in.ua

HTML довідник:
https://developer.mozilla.org/ru/docs/Web/HTML

CSS довідник:
https://developer.mozilla.org/en-US/docs/Web/CSS

Посібник з написання коду:
https://codeguide.co

Ваша перша HTML форма:
https://developer.mozilla.org/en-US/docs/Learn/Forms/Your_first_form

Emmet комбінації:
https://docs.emmet.io/cheat-sheet/

Сервіс для перевірки на правильну вкладеність тегів:
https://caninclude.glitch.me

Словник базових термінів для розробників-початківців та дизайнерів:
https://github.com/YK911/basic-dictionary

Особливості inline-block елементів:
https://css-tricks.com/fighting-the-space-between-inline-block-elements/

Повний посібник з Flexbox:
https://css-tricks.com/snippets/css/a-guide-to-flexbox/

Гра по Flexbox:
http://flexboxfroggy.com/

Ще одна гра на вивчення флексів:
https://mastery.games/flexboxzombies/

Добірка цікавих градієнтів:
https://uigradients.com/

Ще один цікавий оптимізатор картинок:
https://imagecompressor.com/

Position:
https://css-tricks.com/almanac/properties/p/position/

CSS Transition:
https://www.youtube.com/watch?v=8kK-cA99SA0&feature=youtu.be

Готовий CSS код різних анімацій тексту:
https://animate.style/

Футбольне поле (приклад position: absolute)
https://codepen.io/mpadalko/pen/PomeroW?editors=1100

Position: Sticky
https://codepen.io/mpadalko/pen/LYNqpGG

Генератор трикутників:
http://apps.eky.hk/css-triangle-generator/

Приклади з трансформ:
https://codepen.io/nazarelen/pen/EaNbLX?editors=1100

Генератор cubic-bezier:
https://cubic-bezier.com/#.22,.84,.88,.03

My Homework 1
**робота з віддаленим репозиторієм**
git status- перевірка статусу файлів в середовищі.
git add--all - добавити в чергу на пуш.
git commit -m"тут має бути коміт"
git push- запушити зміни на віддалений репозиторій

**Опис структурних тегів:**

1. **`<!DOCTYPE html>`**: Вказує браузеру, що документ використовує HTML5.
2. **`<html lang="uk">`**: Кореневий елемент HTML-документа. Атрибут `lang` визначає мову сторінки.
3. **`<head>`**: Секція для метаінформації про документ, такої як кодування, заголовок, стилі та інші метадані.
4. **`<meta charset="UTF-8">`**: Вказує кодування символів для документа. UTF-8 підтримує більшість символів.
5. **`<meta name="viewport" content="width=device-width, initial-scale=1.0">`**: Налаштовує масштабування на мобільних пристроях.
6. **`<title>`**: Визначає заголовок документа, який відображається на вкладці браузера.
7. **`<link rel="stylesheet" href="styles.css">`**: Підключає зовнішній файл стилів CSS.
8. **`<body>`**: Основний вміст HTML-документа.
9. **`<header>`**

**ПРИКЛАД**

<!DOCTYPE html>
<!-- Вказує, що документ написаний у HTML5. Це важливо для коректної роботи браузерів. -->
<html lang="uk">
<!-- Кореневий елемент HTML-документа. Атрибут lang визначає мову вмісту сторінки. -->
<head>
    <meta charset="UTF-8">
    <!-- Вказує кодування символів для документа. UTF-8 є найпоширенішим кодуванням. -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- Налаштовує viewport для коректного відображення на мобільних пристроях. -->
    <title>Назва сторінки</title>
    <!-- Визначає заголовок сторінки, який відображається на вкладці браузера. -->
    <link rel="stylesheet" href="styles.css">
    <!-- Підключає зовнішній файл стилів (CSS) для оформлення сторінки. -->
</head>
<body>
    <!-- Основний вміст HTML-документа розташовується всередині цього тегу. -->
    <header>
        <!-- Секція для заголовків та навігації. -->
        <h1>Заголовок сайту</h1>
        <!-- Основний заголовок сторінки або сайту. -->
         <nav>
        <!-- Навігаційний розділ для посилань на інші частини сайту. -->
        <ul>
            <!-- Ненумерований список навігаційних посилань. -->
            <li><a href="#section1">Розділ 1</a></li>
            <!-- Елемент списку з посиланням на перший розділ. -->
            <li><a href="#section2">Розділ 2</a></li>
            <!-- Елемент списку з посиланням на другий розділ. -->
        </ul>
    </nav>
    </header>
     <main>
        <!-- Основний контент сторінки. -->
        <section id="section1">
            <!-- Секція для першого розділу контенту. -->
            <h2>Розділ 1</h2>
            <!-- Заголовок другого рівня для першого розділу. -->
            <p>Текст для розділу 1.</p>
            <!-- Параграф тексту для першого розділу. -->
        </section>
        <section id="section2">
            <!-- Секція для другого розділу контенту. -->
            <h2>Розділ 2</h2>
            <!-- Заголовок другого рівня для другого розділу. -->
            <p>Текст для розділу 2.</p>
            <!-- Параграф тексту для другого розділу. -->
        </section>
    </main>
    <footer>
        <!-- Підвал сторінки, що зазвичай містить інформацію про авторські права, контакти тощо. -->
        <p>&copy; 2025 Ваше ім'я</p>
        <!-- Параграф з інформацією про авторські права. -->
    </footer>
</body>
</html>

1. Основні теги та їх використання:

Теги заголовків: <h1>, <h2>, <h3>, <h4>, <h5>, <h6>. Використовуються для заголовків різних рівнів.

Теги абзаців: <p>. Використовується для блоків тексту.

Теги списків: <ul> (ненумерований список), <ol> (нумерований список), <li> (елемент списку).

Теги посилань: <a href="URL">. Використовується для створення гіперпосилань.

Теги зображень: <img src="URL" alt="опис">. Використовується для вставки зображень.

Теги таблиць: <table>, <tr>, <td>, <th>. Використовуються для створення таблиць.

Теги форм: <form>, <input>, <textarea>, <button>, <select>, <option>. Використовуються для створення форм для введення даних.

2. Атрибути:

Атрибути використовуються для налаштування тегів і додають додаткову інформацію.

Основні атрибути та їх використання:
**id:**Унікальний ідентифікатор елемента на сторінці. Може використовуватися для стилізації або скриптів.
**class:**Визначає один або кілька класів для елемента, що дозволяє застосовувати CSS-стилі до групи елементів.
**style:**Додає інлайн-стилі до елемента. Використовується для швидкого стилювання без зовнішніх або внутрішніх CSS.
**title:**Додає текстову підказку, яка з’являється при наведенні миші на елемент.
**hidden:**Використовується для приховування елемента. Якщо атрибут присутній, елемент не відображається на сторінці.
**lang:**Вказує мову вмісту елемента. Це допомагає браузерам і допоміжним технологіям правильно відображати текст.

Приклади для тегу <a></a>
**href:** Вказує URL-адресу, на яку веде посилання.
**target**(Визначає, де відкривати гіперпосилання.):
_\_self:_ відкрити в тому ж вікні/вкладці (за замовчуванням).
_\_blank:_ відкрити в новій вкладці/вікні.
_\_parent:_ відкрити в батьківському фреймі.
_\_top:_ відкрити в повноекранному вікні.
**title**:Додає текстову підказку, яка з’являється при наведенні миші на посилання.
**rel**(Визначає відношення між поточним документом і документом, на який веде посилання.атрибути допомагають контролювати поведінку посилань, покращуючи безпеку та управління SEO.):
_\_nofollow_ Вказує пошуковим системам не слідкувати за цим посиланням.Використовується, коли ви не хочете, щоб ваш сайт підтримував або рекомендував інший сайт,
_\_noopener_ Запобігає доступу нової вкладки (або вікна), відкритої за допомогою target="\_blank", до об'єкта window.opener. Це підвищує безпеку, оскільки перешкоджає атакам, які можуть спробувати використовувати відкриту вкладку для маніпуляції з вихідним документом,
_\_noreferrer_ Запобігає передачі інформації про джерело (реферер) при переході за посиланням. Це означає, що веб-сайт, на який ви переходите, не дізнається, з якого сайту ви прийшли,Також автоматично додає noopener, тому не потрібно використовувати обидва атрибути окремо.
**download**:Використовується для вказівки, що посилання веде на файл, який слід завантажити, а не відкрити.

Приклади для тегу <img>
**src:**Вказує URL-адресу зображення, яке потрібно відобразити.
**alt:** Надає текстовий опис зображення, який відображається, якщо зображення не може бути завантажене.
**title:**Додає текстову підказку, яка з’являється при наведенні миші на зображення. Це може бути додатковою інформацією про зображення.
**width:**Визначає ширину зображення в пікселях або у відсотках. Може допомогти контролювати розміри зображення на сторінці.
**height:** Визначає висоту зображення в пікселях або у відсотках. Як і width, допомагає контролювати розміри зображення.
**loading:**(Використовується для вказівки способу завантаження зображення):
_\_lazy:_ відкладене завантаження зображення, яке з'явиться у видимій частині сторінки.
_\_eager:_ завантаження зображення відразу.

3. Семантичні теги:

Семантичні теги додають змістовності до HTML-документа і допомагають пошуковим системам та браузерам краще розуміти структуру сторінки.

Приклади:

<header>,є семантичним елементом HTML5, який використовується для визначення заголовкової секції документа або розділу. Він зазвичай містить вступну інформацію, навігаційні посилання, логотипи, заголовки та інші елементи, що є початковими для даного розділу або сторінки.
<nav>, використовується для визначення навігаційних посилань на веб-сторінці. Він зазвичай містить списки посилань, які допомагають користувачам переміщатися між різними секціями сайту або сторінками.
<main>,використовується для визначення основного вмісту документа, який є унікальним для конкретної сторінки. Він містить інформацію, що є основною темою або змістом сторінки, і не включає в себе навігаційні елементи, заголовки, футери чи сайдбари.
<section>,в HTML використовується для визначення окремих секцій або частин вмісту на веб-сторінці. Кожна секція зазвичай має свою тему або підрозділ і може містити заголовок, текст, зображення та інші елементи.
<article>- часто використовується для контенту, який публікується окремо або може бути передрукований (наприклад, RSS-стрічка, новинна стаття, блог-пост, відгук користувача).
<footer>,використовується для визначення футера (нижньої частини) документа або секції. Футер зазвичай містить інформацію про авторські права, контактні дані, посилання на політику конфіденційності, інформацію про сайт або інші важливі відомості, що стосуються всього документа або певної секції.
<aside>.в HTML використовується для визначення вмісту, який є побічним або додатковим до основного контенту на веб-сторінці. Зазвичай це інформація, що доповнює основну тему, наприклад, бокові панелі, коментарі, посилання на відповідні статті, рекламу або інші матеріали, які не є основним вмістом, але можуть бути корисними для користувачів.

4. Форми та введення даних:

Форми дозволяють користувачам вводити і відправляти дані.

Різні типи полів введення:
<input type="text">текстові поля,
<input type="password">паролі,
<input type="button"> або <button>кнопки,
<input type="radio">перемикачі,
<input type="checkbox">прапорці,
<select>випадаючі списки,
<textarea>Текстова область,
<input type="file">Поле для завантаження файлів,

5. Мультимедіа:

Вбудовування відео: <video src="video.mp4" controls>.

Вбудовування аудіо: <audio src="audio.mp3" controls>.

6. Метадані та SEO:

Метадані допомагають пошуковим системам та соціальним медіа краще зрозуміти зміст сторінки.

Приклади: <meta name="description" content="Опис сторінки">, <meta name="keywords" content="ключові слова">.

7. Коментарі:

Коментарі використовуються для додавання пояснень або приміток в код і не відображаються на сторінці.

Приклад html: <!-- Це коментар -->.

## goit-markup-hw-02

**Нормалізація стилів**

Нормалізація стилів — це техніка покращення кросбраузерності веб-сторінки — однакового відображення та роботи сайту в різних браузерах.
Для цього можна використовувати готову бібліотеку Modern Normalize (https://github.com/sindresorhus/modern-normalize#readme), яка надає готовий файл стилів із нормалізацією. Все, що потрібно зробити, — це підключити цей файл стилів перед усіма вашими стилями.

**Зовнішня таблиця стилів**

Зовнішній CSS-код (external stylesheet) легко масштабувати, підтримувати та використовувати повторно на інших сторінках. Це стандарт додавання стилів. У проєкті створюється окремий файл стилів з розширенням .css, який додається в HTML-документ.

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>CSS is amazing!</title>
		<link rel="stylesheet" href="./css/styles.css" />
  </head>
  <body></body>
</html>

На одному рівні з index.html створюється папка css, а всередині неї файл стилів styles.css.
У тегу <head> створений раніше файл styles.css додається за допомогою тегу <link>.
В атрибуті href вказується відносний шлях до файлу стилів HTML-документа.
В атрибуті rel вказується тип документа, що додається — stylesheet (таблиця стилів).

**кольори**

1. RGB (Red, Green, Blue) _RGB визначає колір за допомогою трьох основних кольорів: червоного, зеленого та синього. Кожен колір може мати значення від 0 до 255._
   color: rgb(255, 0, 0); _Червоний_

2. HEX (Шістнадцятковий) _HEX-код — це шістнадцяткове представлення кольору, що складається з шести символів. Перші два символи відповідають червоному, наступні два — зеленому, а останні два — синьому._
   color: #FF0000; _Червоний_

3. HSL (Hue, Saturation, Lightness) _HSL описує колір за допомогою відтінку (Hue), насиченості (Saturation) та яскравості (Lightness). Відтінок задається в градусах (0-360), а насиченість і яскравість — у відсотках._
   color: hsl(0, 100%, 50%); /_ Червоний _/

**селектори**

Селектори в CSS використовуються для вибору елементів HTML, до яких будуть застосовані стилі. Ось основні види селекторів:

1. Селектори за тегами _Цей селектор вибирає всі елементи певного типу_
   p {
   color: blue; /_ Всі <p> елементи будуть синіми _/
   }

2. Селектори класів _Вибирає елементи з певним класом. Класи позначаються крапкою (.)_
   .button {
   background-color: green; /_ Всі елементи з класом "button" будуть зеленими _/
   }

3. Селектори ідентифікаторів _Вибирає єдиний елемент з певним ідентифікатором. Ідентифікатори позначаються символом решітки (#)_
   #header {
   font-size: 24px; /_ Елемент з id "header" буде з шрифтом 24px _/
   }

4. Атрибутні селектори _Вибирає елементи за значенням атрибутів._
   input[type="text"] {
   border: 1px solid black; /_ Всі текстові поля будуть з чорним бордером _/
   }

5. Селектори нащадків _Вибирає елементи, які є нащадками певного батьківського елемента._
   div p {
   color: red; /_ Всі <p> всередині <div> будуть червоними _/
   }

6. Селектори сусідніх елементів _Вибирає елемент, який безпосередньо йде після іншого._
   h1 + p {
   margin-top: 0; /_ <p> після <h1> не буде верхнього відступу _/
   }

7. Селектори загальних сусідів _Вибирає всі елементи, які йдуть після певного елемента, незалежно від того, які елементи між ними._
   h1 ~ p {
   color: gray; /_ Всі <p> після <h1> будуть сірими _/
   }

8. Групування селекторів _Дозволяє застосовувати однакові стилі до кількох селекторів._
   h1, h2, h3 {
   font-family: Arial; /_ Всі заголовки будуть з шрифтом Arial _/
   }

9. Псевдокласи _Вибирають елементи в особливих станах, наприклад, при наведенні миші._
   a:hover {
   color: orange; /_ Посилання стане оранжевим при наведенні курсора _/
   }

10. Псевдоелементи _Вибирають частини елемента, наприклад, перший рядок або перший символ._
    p::first-line {
    font-weight: bold; /_ Перший рядок у всіх <p> буде жирним _/
    }

**Каскадування** — це механізм, який керує кінцевими значеннями властивостей елемента, якщо до нього застосовується кілька CSS-правил.
*Якщо до елемента застосовується кілька правил, їх властивості поєднуються.
*Якщо в правилах є однакові властивості з різними значеннями, то вони конфліктують.
Для того, щоб зібрати фінальні стилі елемента й вирішити конфлікти значень властивостей, браузер використовує два механізми: специфічність та успадкування.
Розуміння специфічності селекторів допомагає ефективніше контролювати стилі на веб-сторінках і уникати конфліктів у стилях. Це важливий аспект роботи з CSS, особливо в великих проектах.

1. Інлайн-стилі: Стилі, що встановлені безпосередньо в атрибуті style HTML-елемента. Вони мають найвищу специфічність.

Специфічність: 1-0-0-0

   <div style="color: red;">Text</div>

2. ID-селектори: Селектори, які вибирають елементи за їхнім ідентифікатором. Вони мають високу специфічність.

Специфічність: 0-1-0-0

#header {
color: blue;
}

3. Класові, атрибутні та псевдокласові селектори: Селектори класів, атрибутів та псевдокласів, які мають середню специфічність.

Специфічність: 0-0-1-0

.button {
color: green;
}

4. Тегові (елементні) селектори та псевдоелементи: Селектори, які вибирають елементи за їхнім тегом. Вони мають найнижчу специфічність.

Специфічність: 0-0-0-1

p {
color: black;

}

**Обчислення специфічності**

Коли CSS обробляє стилі, він обчислює специфічність селекторів у такому порядку:

1. Інлайн-стилі мають найвищу специфічність.

2. ID-селектори йдуть далі.

3. Класові селектори, атрибутні селектори та псевдокласи мають середню специфічність.

4. Тегові селектори та псевдоелементи мають найнижчу специфічність.

\_Приклад обчислення специфічності\_

Розгляньмо наступний код:
#header {
color: blue; /_ Специфічність 0-1-0-0 _/
}

.button {
color: green; /_ Специфічність 0-0-1-0 _/
}

p {
color: black; /_ Специфічність 0-0-0-1 _/
}

<div id="header" class="button">
    <p>Text</p>
</div>

- Для елемента `<div>`: специфічність буде 0-1-1-0 (ID + клас).
- Для `<p>`: специфічність буде 0-0-0-1.

Отже, текст всередині `<div>` буде синім, оскільки специфічність селектора `#header` вища, ніж у класу `.button` та тегу `p`.

**Ключове слово !important**
Специфічність правила можна підвищити за допомогою ключового слова !important, якщо додати його після значення властивості.
Значення властивості з !important пріоритетніше за інші
_Єдиним прийнятним випадком є перевизначення значення властивості, якщо немає прямого доступу до файлу зі стилями, наприклад, стиль бібліотеки._

**Атрибут class і підходи для використовування селекторів класу**

1. Присвоєння класу лише загальному блоку
   /_Перший підхід — це присвоєння класу загальному блоку-батьку та використання дочірніх селекторів та нащадків._/
   Такий CSS-код добре працює, коли розмітка проста.
   Але при зростанні складності розмітки блоку, якому надано окремий клас (наприклад .post) зручна стилізація за селектором тегу (тобто, .post > h1 , .post > link) стає неможливою. Наприклад, якщо в пості буде 5 посилань, а не одне, точково вибрати якесь посилання не вийде, або селектор буде заскладний.
2. Описові класи для блока-батька та тегів всередені
   Другий підхід — це додавання описових класів блоку-батькові і тегам всередині нього
   Такий CSS-код непогано масштабується та підтримується.
   Це відправна точка для написання гарного CSS. Проте, при зростані складності розмітки можуть виникнути невеликі проблеми зі специфічністю.
3. Специфічні класи для кожного тегу
   Третій підхід полягає в завданні дуже специфічних класів блоку-батьку і кожному тегу всередині нього за принципом “ім'я батька — ім'я дитини”.
   При цьому підході використовуються прості селектори класу, не треба думати про специфічність. Такий CSS-код добре масштабується і підтримується. У розробці при написанні стилів використовуються варіації цього підходу.

.post {
/_ Стилі статті _/
}

.post-section {
/_ Стилі секції _/
}

.post-title {
/_ Стилі заголовку _/
}

.post-subtitle {
/_ Стилі підзаголовку _/
}

.post-text {
/_ Стилі тексту _/
}

.post-list {
/_ Стилі списку _/
}

.post-item {
/_ Стилі пунктів _/
}

.post-img {
/_ Стилі картинок _/
}

.post-link {
/_ Стилі посилань _/
}

.post-link:hover {
/_ Стилі посилань при наведенні _/
}

**Успадкування властивостей**

Успадкування властивостей у CSS — це механізм, який дозволяє деяким стилям автоматично застосовуватися до дочірніх елементів, якщо ці стилі не були переопрацьовані. Це дозволяє зменшити кількість коду і спростити управління стилями на веб-сторінках.

_Основи успадкування_

1. Успадковувані властивості: Деякі CSS-властивості успадковуються за замовчуванням. Наприклад, такі властивості, як
   color, font-family, font-size, line-height, успадковуються дочірніми елементами.
2. Неуспадковувані властивості: Інші властивості, такі як margin, padding, border, не успадковуються. Для таких
   властивостей вам потрібно задати стилі для кожного елемента окремо.

_Як працює успадкування_

1. Дочірні елементи: Якщо елемент має стилі, які успадковуються, тоді всі його дочірні елементи також отримують ці
стилі.
   <div class="parent">
    <p>Цей текст успадковує колір батьківського елемента.</p>
</div>

2. Перезапис успадкування: Дочірні елементи можуть перезаписати успадковані стилі, якщо для них задані нові значення.
   .child {
   color: red; /_ Перезаписує успадкований колір _/
   }

_Керування успадкуванням_

1. Властивість inherit: Ви можете явно вказати, що певна властивість має успадковуватися, використовуючи значення inherit.
   .child {
   color: inherit; /_ Дочірній елемент успадковує колір батька _/
   }
2. Властивість initial: Вона скидає властивість до її початкового значення, яке визначено в специфікації CSS.
   .child {
   color: initial; /_ Скидає колір до початкового значення _/
   }
3. Властивість unset: Ця властивість скидає значення до успадкованого, якщо воно успадковується, або до початкового значення, якщо не успадковується.
   .child {
   color: unset; /_ Залежить від контексту _/
   }

_Приклади успадкування_

html

<div class="parent">
    <p class="child">Цей текст буде Arial, синій, з шрифтом 20px.</p>
</div>

css
.parent {
font-family: Arial, sans-serif; /_ Успадковується _/
color: blue; /_ Успадковується _/
}

.child {
font-size: 20px; /_ Не успадковується, це нове значення _/
}

**властивості шрифтів**

1. font-family _Визначає тип шрифту для елемента. Можна вказати кілька шрифтів для резервування._
2. font-size _Визначає розмір шрифту. Можна використовувати різні одиниці виміру: px, em, rem, % тощо._
3. font-weight _Визначає товщину шрифту. Можна використовувати значення від 100 до 900, або ключові слова: normal, bold, bolder, lighter._
4. font-style:normal | italic | oblique | initial | inherit _Визначає стиль шрифту, наприклад, курсив або нормальний._
5. font-variant _Визначає, чи використовувати малий caps (small-caps) для шрифту._
6. font-display — керує відображенням тексту під час завантаження шрифту.
7. text-transform: none | uppercase | lowercase | capitalize _Визначає, як текст буде відображатися (всі великі літери, всі малі літери тощо)._
8. letter-spacing: значення | normal | inherit _Визначає відстань між літерами._
9. word-spacing _Визначає відстань між словами._
10. text-align: left | right | center | justify _Визначає вирівнювання тексту (ліворуч, праворуч, по центру, по ширині)._
11. text-decoration: none | underline | line-through | overline _Визначає стилі декорування тексту, такі як підкреслення, закреслення тощо._
12. text-shadow: <зміщення по x>, <зміщення по y>, <радіус розмиття>, <колір> _Додає тінь до тексту._
    Розберемо кожен параметр окремо:
    колір \*\*\*\*— задається в будь-якому форматі. За умовчанням колір тіні збігається з кольором тексту.
    зміщення по x — зсув тіні по горизонталі щодо тексту. Позитивне значення задає зсув тіні праворуч, негативне — ліворуч.
    зміщення по y — зсув тіні по вертикалі щодо тексту. Позитивне значення задає зсув тіні донизу, негативне — вгору.
    радіус розмиття — радіус розмиття: що більше значення, то сильніше тінь розмивається і стає світлішою. За умовчанням, якщо не заданий, дорівнюватиме 0

13. line-height: множник | значення | відсотки | normal | inherit _Визначає відстань між рядками тексту. Може бути задано як число, відсоток або одиниця виміру._
14. text-indent: значення | відсотки | inherit _встановлює величину відступу першого рядка текстового блоку, наприклад абзацу._

**Глобальні стилі документа**

Глобальні стилі документа — це набір успадкованих і не успадкованих CSS-властивостей, зазначених у правилі тегу body, а також набір CSS-правил для завдання глобальних значень по селекторам тегу.

body {
font-family: ;
color:;
background-color:;
line-height: ;
}

ul, ol {
list-style-type: none;
}

a{
text-decoration:none;
}

button {
cursor: pointer;
}

# goit-markup-hw-03

**Блокова модель**

_Блокова модель (Box Model)_ у CSS є основною концепцією, яка описує, як елементи веб-сторінки обробляються та відображаються на екрані. Кожен HTML-елемент розглядається як прямокутний блок, що складається з кількох частин:

Складові блокової моделі:

1. Content (Вміст): Це внутрішня частина блоку, де розміщується текст, зображення або інший контент. Розмір вмісту визначається властивістю width і height.

2. Padding (Внутрішні відступи): Це простір між вмістом і краєм блоку. Внутрішні відступи додають простір всередині блоку, не змінюючи його розмір. Властивості padding можуть бути вказані для всіх боків або окремо для кожного.
   /_ Поле зверху 10px, праворуч 15px, знизу 20px, ліворуч 25px _/
   padding: 10px 15px 20px 25px;

3. Border (Рамка): Це межа навколо блоку. Вона може мати різні стилі, товщину та кольори. Властивості border дозволяють налаштувати рамку.

4. Margin (Зовнішні відступи): Це простір зовні блоку, що відокремлює його від інших елементів. Зовнішні відступи не впливають на розмір блоку, але можуть змінити його положення. Властивості margin також можуть бути вказані для всіх боків або окремо.
   /_ Відступ зверху 10px, праворуч 15px, знизу 20px, зліва 25px _/
   margin: 10px 15px 20px 25px;

**Візуалізація блокової моделі**

<pre>
                top
      +-------------------------+
      |         Margin          |
      |  +-------------------+  |
      |  |      Border       |  |
      |  |  +-------------+  |  |
left  |  |  |   Padding   |  |  |  right
      |  |  | +---------+ |  |  |
      |  |  | | Content | |  |  |
      |  |  | +---------+ |  |  |
      |  |  +-------------+  |  |
      |  +-------------------+  |
      +-------------------------+
                bottom
</pre>

**Важливі моменти**

1. Ширина та висота: Коли ви задаєте ширину (width) і висоту (height) блоку, це зазвичай стосується лише вмісту (content). Щоб отримати повний розмір елемента, потрібно враховувати також padding, border і margin.

2. box-sizing: Властивість box-sizing дозволяє змінити поведінку блоку. Значення border-box включає padding і border у ширину та висоту блоку, що робить управління розмірами більш зручним.

**Глобальне скидання стилів**
Глобальне скидання стилів (CSS Reset) — це метод, що використовується для скасування стандартних стилів, які браузери автоматично застосовують до HTML-елементів. Це допомагає забезпечити узгоджений вигляд веб-сторінки на різних браузерах, оскільки різні браузери можуть мати свої власні стилі за замовчуванням.

Основні методи скидання стилів

1. CSS Reset
   Один з найпоширеніших підходів — використання CSS Reset, який надає базові стилі для усіх елементів.

2. Normalize.css
   Normalize.css — це популярна бібліотека, яка не просто скидає стилі, а також нормалізує їх. Вона забезпечує більш узгоджене відображення елементів у різних браузерах, зберігаючи при цьому корисні стилі.

3. Мінімальний скидання стилів
   Інший підхід — лише скидання специфічних елементів, які часто викликають проблеми:

h1, h2, h3, h4, h5, h6 {
margin: 0;
padding: 0;
}

ul, ol {
list-style: none; /_ Вимкнення маркерів _/
}

**Властивість border**

Складова властивість border контролює ширину, стиль і колір рамки елемента.

border: ширина стиль колір;

Ширина рамки визначається в пікселях.
Стиль — одне значення з набору можливих значень, найпоширенішими значеннями є solid, dashed і dotted.
Колір задається в будь-якому форматі, зазвичай HEX

.box {
width: 200px;
height: 200px;
border: 5px solid orangered;
}

Аби _заокруглити_ всі кути рамки, застосовується властивість border-radius. Значення можуть бути як абсолютні (px), так і відносні (%). Якщо квадратному елементу задати радіус 50%, це перетворить його на коло.

**властивість overflow** використовується для контролю поведінки вмісту, який виходить за межі блоку. Ця властивість визначає, що відбувається, коли вміст елемента перевищує його видиму область.

_Основні значення overflow_

overflow: visible | hidden | scroll | auto

1. visible (за замовчуванням)
   Вміст, який виходить за межі блоку, буде видимим. Ніякого обрізання не відбувається.
2. hidden
   Вміст, що перевищує межі блоку, буде обрізаний, і не буде видимим.
3. scroll
   Усі вмісти будуть обрізані, але на елементі з’являться смуги прокрутки (горизонтальна та/або вертикальна), навіть якщо вони не потрібні.
4. auto
   Якщо вміст перевищує межі блоку, браузер автоматично відображає смуги прокрутки. Якщо вміст поміщається, смуги прокрутки не з’являються.

_Властивість overflow-x та overflow-y_
Крім загальної властивості overflow, можна використовувати overflow-x і overflow-y, щоб контролювати прокрутку окремо для горизонтального та вертикального напрямків.
overflow-x: Визначає прокрутку по горизонталі.
overflow-y: Визначає прокрутку по вертикалі.

**Типи елементів**

1. Блокові елементи (Block-level elements)
   Ці елементи займають всю ширину контейнера і починаються з нового рядка. Вони використовуються для створення основних структурних частин веб-сторінки.

Приклади:

<div>: Контейнер для групи елементів.

<p>: Параграф тексту.

<h1>, <h2>, <h3>, ...: Заголовки різних рівнів.

<ul>, <ol>: Нумеровані та маркеровані списки.

<blockquote>: Цитата.

2. Інлайнові елементи (Inline elements)
   Ці елементи займають лише стільки місця, скільки потрібно для їхнього вмісту, і не починають новий рядок. Вони зазвичай використовуються для форматування тексту.

Приклади:

<span>: Контейнер для групи тексту.

<a>: Гіперпосилання.

<strong>: Виділення тексту (жирний шрифт).

<em>: Накреслення тексту (курсив).

<img>: Зображення.

3. Інлайново-блокові елементи (Inline-block elements)
   Ці елементи поєднують риси блокових і інлайнових елементів: вони можуть мати задані ширину і висоту, але не починають новий рядок.

Приклади:

<button>: Кнопка.

<input>: Поле вводу.

<label>: Мітка для елементів форми.

4. Форматувальні елементи
   Ці елементи використовуються для форматування тексту або додавання стилів.

Приклади:

<b>: Жирний текст (не семантично).

<i>: Курсив (не семантично).

<u>: Підкреслений текст.

5. Системні елементи
   Ці елементи використовуються для створення форм і взаємодії з користувачем.

Приклади:

<form>: Форма для введення даних.

<input>: Поле вводу.

<select>: Список вибору.

<textarea>: Поле для багаторядкового вводу тексту.

6. Семантичні елементи
   Ці елементи мають специфічне значення і допомагають покращити структуру документа, а також SEO.

Приклади:

<header>: Заголовок документа або секції.

<nav>: Навігаційне меню.

<article>: Стаття.

<section>: Секція в документі.

<footer>: Нижній колонтитул документа або секції.

**display**

Властивість display у CSS визначає, як елемент буде відображатися в документі. Це одна з найважливіших властивостей для управління макетом веб-сторінки.

Основні значення display:

display: block/inline/inline-block/none/flex/grid/table/table-row/table-cell

1. block
   Елемент займає всю ширину контейнера та починається з нового рядка. Використовується для блокових елементів.
2. inline
   Елемент займає лише стільки місця, скільки потрібно для його вмісту, і не починає новий рядок. Використовується для інлайнових елементів.
3. inline-block
   Це комбінація блокового та інлайнового відображення. Елемент поводиться як інлайновий, але дозволяє встановлювати ширину та висоту.
4. none
   Елемент не відображається на сторінці, і його не займає місце в макеті. Використовується для приховування елементів.
5. flex
   Визначає контейнер для флекс-елементів. Це дозволяє використовувати модель флекс-контейнера для управління розміщенням елементів у рядку або стовпці.
6. grid
   Визначає контейнер для CSS Grid Layout. Це дозволяє створювати двомірні макети.
7. table
   Визначає, що елемент буде відображатися як таблиця. Це можна використовувати для створення таблиць без використання елементів <table>.
8. table-row
   Визначає, що елемент буде відображатися як рядок таблиці.
9. table-cell
   Визначає, що елемент буде відображатися як клітинка таблиці.

**Колапсування вертикальних маржинів**

Колапсування вертикальних маржинів — це особливість у CSS, коли вертикальні відступи (margin) сусідніх блокових елементів об'єднуються (колапсують), а не додаються разом. Це може призвести до неочікуваних результатів у макеті.

**Випадання вертикальних маржинів**

Вертикальний маржин вкладеного блоку випадає з батьківського та відштовхує обидва блока (батьківський та вкладений) від сусіда або верха сторінки.
Якщо у батьківського елемента також був заданий верхній маржин, то застосується те значення маржину, що є більшим.

**Горизонтальне центрування блокових елементів**

Горизонтальне центрування блокових елементів може бути виконане різними способами, і найкращий метод вибирається в залежності від специфіки вашого макету та контексту. Використання `margin: auto`, Flexbox або CSS Grid є найпоширенішими і зручними способами для досягнення цієї мети.

**Зображення**

Зображення — це рядковий елемент. Отже, між двома зображеннями чи зображенням і іншим рядковим елементом буде відстань по горизонталі.

На практиці, при роботі із зображеннями їх завжди роблять блоковими.

img {
display: block;
}

**_Властивість max-width_**

Властивість `max-width` є корисним інструментом для контролю адаптивності елементів на веб-сторінці. Вона дозволяє уникати ситуацій, коли елементи стають занадто широкими на великих екранах, що покращує вигляд і читабельність контенту.

Основні особливості max-width

1. Блокування ширини: max-width не впливає на ширину елемента, якщо його ширина (width) менша за max-width. Якщо вказана ширина перевищує значення max-width, елемент буде обмежений до цієї максимальної ширини.

2. Одиниці виміру: max-width може приймати значення у різних одиницях, таких як px, %, em, rem тощо.

3. Необов'язкове використання: Якщо max-width не задано, елемент може займати всю доступну ширину контейнера.

**_Властивість object-fit_**

Властивість object-fit використовується для управління відображенням медіа в адаптивних макетах і дозволяє досягати бажаного вигляду без спотворення вмісту. Це особливо корисно для створення галерей, слайдерів та інших елементів, де важлива естетика і правильне відображення медіа без втрати якості.

object-fit: fill | contain | cover | scale-down | none

1. fill: Це значення за замовчуванням. Вміст заповнює весь контейнер, але може деформуватися, якщо його пропорції не збігаються з пропорціями контейнера.

2. contain: Вміст зберігає свої пропорції, і поміщається всередині контейнера, максимально заповнюючи його. Можливі порожні області (пустоти) з боків або зверху/знизу.

3. cover: Вміст також зберігає свої пропорції, але заповнює весь контейнер. Частина вмісту може бути обрізана, якщо його пропорції не збігаються з пропорціями контейнера.

4. none: Вміст не буде змінювати свої розміри. Він відображатиметься в своїх оригінальних розмірах, навіть якщо вони перевищують розміри контейнера.

5. scale-down: Вміст буде зменшено до розміру, що відповідає значенням none або contain, залежно від того, що менше. Це означає, що вміст зберігає свої пропорції, і якщо він більший за контейнер, то зменшується, але не буде збільшений, якщо менший.

**Flexbox**

_Flexbox (Flexible Box Layout)_ — це сучасний метод управління макетом, який дозволяє легко і ефективно розташовувати елементи на веб-сторінках. Flexbox спрощує створення адаптивних і складних макетів, дозволяючи контролювати розміщення, вирівнювання та порядок елементів у контейнері.

**_Основні поняття Flexbox_**

1. Контейнер Flex: Це елемент, на якому застосовується властивість display: flex;. Усі його дочірні елементи стають flex-елементами.

2. Flex-елементи: Це дочірні елементи контейнера flex, які можуть бути розташовані в ряд або стовпець, а також можуть змінювати свої розміри відповідно до доступного простору.

**_Основні властивості Flexbox_**
**_Для контейнера Flex_**

1. display: Встановлює контейнер як flex. Може бути flex або inline-flex.

2. flex-direction: Визначає напрямок основної осі (ряд або стовпець). Значення: row, row-reverse, column, column-reverse.

3. flex-wrap: Визначає, чи потрібно переносити flex-елементи на новий рядок або стовпець. Значення: nowrap, wrap, wrap-reverse.

4. justify-content: Визначає, як flex-елементи вирівнюються уздовж основної осі. Значення: flex-start, flex-end, center, space-between, space-around, space-evenly.

5. align-items: Визначає, як flex-елементи вирівнюються уздовж поперечної осі. Значення: flex-start, flex-end, center, baseline, stretch.

6. align-content: Визначає, як групи flex-елементів вирівнюються, якщо є додатковий простір на поперечній осі (при наявності кількох рядків). Значення: flex-start | flex-end | center | space-between | space-around | space-evenly | stretch

**_Для flex-елементів_**

Flex-елементи — це діти flex-контейнера, елементи першого рівня вкладеності.

1. flex-grow: Визначає, як елемент може рости, щоб заповнити доступний простір. Значення — не від'ємне число.

2. flex-shrink: Визначає, як елемент може зменшуватися, якщо не вистачає місця. Значення — не від'ємне число.

3. flex-basis: Визначає початковий розмір елемента перед розподілом залишкового простору. Може бути вказаний у пікселях, відсотках тощо.

4. flex: Скомбіноване значення для flex-grow, flex-shrink і flex-basis.

5. align-self: Дозволяє перевизначити вирівнювання конкретного flex-елемента на поперечній осі, незалежно від налаштувань контейнера.Значення: auto | flex-start | flex-end | center | baseline | stretch

6. order: позиція; візуально змінює порядок розташування елементів уздовж main axis.

!_У flex-контейнері скасовується_ більшість правил розташування елементів відповідно до їх типу та потоку документа.
— Елементи втрачають «тип», перестають бути рядковими або блоковими, вони стають flex-елементами.
— Блокові елементи перестають йти вертикально один під одним.
— Маржини елементів на краю батьківського елементу не випадають.
— Вертикальні маржини не схлопуються.
— Працюють автоматичні вертикальні відступи.

**_Головні осі flex-контейнера_**

1. Основна вісь (Main Axis)
   Це вісь, вздовж якої flex-елементи розташовуються в контейнері.
   Напрямок основної осі визначається властивістю flex-direction, яка може мати значення:

row: Основна вісь йде горизонтально зліва направо.

row-reverse: Основна вісь йде горизонтально справа наліво.

column: Основна вісь йде вертикально зверху вниз.

column-reverse: Основна вісь йде вертикально знизу вгору.

2. Поперечна вісь (Cross Axis)
   Це вісь, перпендикулярна до основної осі. Вона використовується для вирівнювання flex-елементів на поперечній осі.
   Напрямок поперечної осі завжди протилежний основній осі:

Якщо основна вісь горизонтальна (row або row-reverse), поперечна вісь буде вертикальною.

Якщо основна вісь вертикальна (column або column-reverse), поперечна вісь буде горизонтальною.

_Використання осей_

Вирівнювання по основній осі: Використовується властивість justify-content, щоб контролювати, як елементи розподіляються вздовж основної осі.

Вирівнювання по поперечній осі: Використовується властивість align-items для вирівнювання елементів на поперечній осі.

**_Властивість gap_**

Властивість gap використовується для визначення відстані між елементами в контейнерах з використанням Flexbox або CSS Grid. Це дозволяє легко контролювати простір між дочірніми елементами без необхідності задавати окремі відступи для кожного елемента.

_Значення gap_

1. Одне значення: Якщо вказати одне значення, це значення буде застосовано до обох напрямків (горизонтального та вертикального).

2. Два значення: Якщо вказати два значення, перше значення буде застосовано для горизонтальної відстані, а друге — для вертикальної.

! Властивість _gap комбінує в собі значення властивостей_ row-gap і column-gap, які дозволяють окремо задати розміри проміжків між рядками та стовпцями сітки. Використовуйте gap, коли проміжки однакові. В іншому разі підійдуть row-gap і column-gap.

**CSS-функція calc()**

CSS-функція calc() дозволяє виконувати обчислення безпосередньо в стилях, що робить її дуже корисною для динамічного визначення значень властивостей. Вона дозволяє комбінувати різні одиниці виміру, такі як пікселі (px), відсотки (%), ем (em), рем (rem) і інші.
Це дозволяє створювати адаптивні макети, де розміри елементів залежать від інших значень. Наприклад, ви можете задати ширину елемента як 100% мінус певну величину.

(100% - кількість проміжків у рядку \* значення одного проміжку) / кількість елементів у рядку

.item {
width: calc((100% - 20px) / 3);
}

**_Структурні псевдокласи_**

Структурні псевдокласи в CSS використовуються для вибору елементів на основі їхнього порядку в документі або їхньої структури. Вони дозволяють стилізувати елементи без необхідності додавання класів або ідентифікаторів у HTML.

1. :first-child
   Вибирає елемент, який є першим дитиною свого батьківського елемента.

2. :last-child
   Вибирає елемент, який є останнім дитиною свого батьківського елемента.

3. :nth-child(n)
   Вибирає елемент, який є n-им дитиною свого батьківського елемента, де n може бути числом, формулою або ключовим словом.

Приклади:

:nth-child(2) — вибирає другого дитини.

:nth-child(odd) — вибирає всі непарні діти.

:nth-child(even) — вибирає всі парні діти.

:nth-child(an + b) - вибирає елементи в колекції сусідів за номером, вказаним у дужках, за допомогою циклу an + b `, який дозволяє задати правило для послідовності елементів.
a — період циклу. Довільне число.
n — лічильник циклу. Починається з нуля та збільшується на одиницю на кожній ітерації.
b — зміщення. Довільне число.

4. :nth-of-type(n)
   Вибирає елемент, який є n-им з певного типу серед своїх братів (одного типу).

5. :first-of-type
   Вибирає перший елемент певного типу серед його братів.

6. :last-of-type
   Вибирає останній елемент певного типу серед його братів.

7. :only-child
   Вибирає елемент, який є єдиним дочірнім елементом свого батька.

8. :only-of-type
   Вибирає елемент, який є єдиним дочірнім елементом свого типу серед братів.

_Псевдоклас :not()_

Псевдоклас :not() дозволяє вибрати всі елементи, що не підходять під критерій.

.list-item:not(:last-child) {
margin-bottom: 20px;
}

# goit-markup-hw-04

**Контентні та декоративні зображення**

є два типи зображень:

1. контентні: несуть смислове навантаження, відносяться до вмісту сторінки та допомагають донести до користувача корисну інформацію. _<img> з обов'язково заповненим атрибутом alt_
2. декоративні: використовуються для додаткового оформлення. Вони не несуть корисної інформації та є елементами дизайну. _<svg>_

**_Властивість background-image_**: задає фонове зображення елемента, адреса якого вказується аргументом функції url().

background-image: url(шлях до зображення);

! Елемент фону поширюється лише на область вмісту і падінг і ніколи на маржин, бо маржин є зовнішнім відступом.

**_Властивість background-repeat_**: керує повторенням фонового зображення. За замовчуванням воно повторюється по горизонталі (X) та вертикалі (Y).

background-repeat: repeat | repeat-x | repeat-y | no-repeat

1. repeat — повторювати X і Y. Значення за замовчуванням.
2. repeat-x — повторювати тільки X, тобто по горизонталі.
3. repeat-y — повторювати тільки Y, тобто по вертикалі.
4. no-repeat — не повторювати.

**_Властивість background-position_**: керує положенням фонового зображення відносно рамки елемента, використовуючи дві координати — x по горизонталі і y по вертикалі.

background-position: x y;

У якості значення можна використовувати абсолютні (px) чи відносні (%) одиниці, і навіть ключові слова (top, bottom, right, left, center).
За замовчуванням задане значення left для x і top для y, тобто фон позиціонується відносно верхнього лівого кута елемента.

**_Властивість background-size_** : дозволяє коригувати розміри зображення шляхом налаштування необхідної ширини та висоти. Якщо не вказати висоту, вона буде розрахована автоматично зі збереженням пропорцій.

background-size: auto | значення | cover | contain

1. Значення cover:
   Гарантовано зберігає пропорції зображення.
   Зображенню задані мінімальні розміри, за яких воно заповнить фон всього елемента.
   Якщо пропорції зображення та елемента різні, частина зображення по вертикалі або горизонталі візуально обрізається.
2. Значення contain:
   Гарантовано зберігає пропорції зображення.
   Зображенню задані максимально можливі розміри, за яких воно повністю поміщається в елемент.
   Зображення може не закрити весь фон елемента по вертикалі або горизонталі, якщо пропорції блоку та зображення не збігаються.

**_Основні принципи багатошарового фону_**: Багатошаровий фон у CSS дозволяє використовувати кілька фонів для одного елемента, створюючи складні візуальні ефекти. Це досягається за допомогою властивості background, яка підтримує декілька значень для фону. Кожен новий фон накладається на попередній, що дозволяє створювати цікаві композиції.

1. Властивість background: Ви можете задавати кілька фонових зображень, кольорів, градієнтів, що розділяються комами.

2. Порядок шарів: Фони накладаються один на одного в порядку, в якому вони задані. Перший фон, вказаний у списку, буде на задньому плані, а останній — на передньому.

3. Координати та повторення: Для кожного фону можна вказати координати (позицію), правило повторення (наприклад, no-repeat, repeat, repeat-x, repeat-y) і розмір (використовуючи background-size).

.element {
background-image: url('background1.jpg'), url('background2.png');
background-position: center, top right; /_Позиція для кожного фону_/
background-repeat: no-repeat, no-repeat; /_Без повторення_/
background-size: cover, contain; /_Розмір для кожного фону_/
}

**_Лінійний градієнт_** : це ефект, який дозволяє плавно переходити від одного кольору до іншого вздовж прямої лінії. Він використовується в якості фону або для заповнення елементів, додаючи глибини та візуального інтересу до дизайну.

<pre>
background-image: linear-gradient(
	<напрямок>, 
	<колір-1>, 
	<колір-2>, 
	<колір-3>, 
	...
);
</pre>

Основні параметри:

1. Напрямок: Визначає, в якому напрямку буде проходити градієнт. Напрямок можна вказати у градусах (наприклад, 0deg, 90deg, 180deg, 270deg) або за допомогою ключових слів:

to top
to right
to bottom
to left
to top right
to bottom left тощо.

2. Кольори: Це кольори, які будуть використовуватися в градієнті. Ви можете вказати кілька кольорів, які відокремлюються комами.

3. Кольорові зупинки: Ви можете також вказати позицію кольорів у відсотках або одиницях, щоб контролювати, де колір змінюється.

Оскільки градієнт — це фонове зображення, розглянемо техніку подвійного фону, коли над зображенням розташовується шар кольору із прозорістю.

1. Першим верхнім шаром задаємо градієнт із прозорістю, при цьому використовуємо однакове початкове і кінцеве значення кольору. Значення кольору градієнта залежать від дизайну, тож нехай це буде червоний колір із 30% прозорістю. Напрямок градієнта задаємо зверху вниз.
2. Другим шаром додаємо фонове зображення.

<pre>
background-image: linear-gradient(
	to bottom, 
	rgba(255, 0, 0, 0.3), 
	rgba(255, 0, 0, 0.3)
	),
	url(шлях до зображення);
</pre>

**_Властивість background_** : це складена властивість для одночасного встановлення значень всіх розглянутих властивостей.

background: background-color background-image background-repeat background-position background-attachment background-size

Якщо компонент не вказано, використовується його значення за замовчуванням.
/_ Встановить лише колір фону _/
background: #2a2a2a;

/_ Прозорий колір фону з картинкою, що повторюється по x, починаючи з верхнього лівого кута. _/
background: url(шлях до зображення) repeat-x;

**Тінь елемента**
**_Властивість box-shadow_** : задає елементу одну або більше тіней. За замовчуванням розмір тіні збігається з розміром елемента, а її колір такий самий, як і колір його тексту.

box-shadow: <inset> <x-offset> <y-offset> <blur> <spread> <color>;

1. inset (необов'язковий): Якщо вказати, тінь буде внутрішньою, тобто вона буде зсередини елемента, а не зовні.
2. x-offset — горизонтальне зміщення. Позитивне значення зміщує тінь праворуч від блоку, негативне - ліворуч. Обов'язкове значення.
3. y-offset — вертикальне зміщення. Позитивне значення зміщує тінь вниз, негативне - вгору. Обов'язкове значення.
4. blur — радіус розмиття. Чим більше значення, тим сильніше розмита тінь. Необов'язкове значення.
5. spread-radius — радіус поширення. Позитивне значення збільшує тінь, негативне — зменшує. Необов'язкове значення.
6. color — колір тіні. Можна використовувати будь-який формат запису кольору. Необов'язкове значення.

**_Багатошарова тінь_** : Виходить щось схоже на багатошаровий пиріг. Перша тінь у списку розміщується вгорі, остання — у самому внизу. Тобто кожна попередня тінь зі списку розташовується на вищому шарі і візуально перекриває всі наступні.

<pre>
box-shadow: <inset> <x-offset> <y-offset> <blur> <spread> <color> ,
            <inset> <x-offset> <y-offset> <blur> <spread> <color> ,
            <inset> <x-offset> <y-offset> <blur> <spread> <color> ;
</pre>

**Векторна графіка**
**_AI (Adobe Illustrator)_**: Формат, що використовується в програмі Adobe Illustrator.
**_EPS (Encapsulated PostScript)_**: Формат, який часто використовується для обміну векторною графікою між різними програмами.
**_SVG (Scalable Vector Graphics)_** : формат графіки та мова для опису векторних зображень. Всередині файл не бінарний, а звичайний текст (XML), що описує об'єкти, їх ефекти та поведінку.

1. Масштабованість: Векторні зображення можна безмежно збільшувати або зменшувати без втрати якості. Це робить їх ідеальними для логотипів, іконок та інших графічних елементів, які потребують різних розмірів.

2. Легкий об’єм: Векторні файли зазвичай мають менший розмір порівняно з растровими зображеннями (які складаються з пікселів), оскільки вони зберігають лише математичні описи форм.

3. Редагування: за допомогою CSS і JavaScript можна змінювати параметри векторного зображення вони легше редагувати, оскільки ви можете змінювати окремі елементи (наприклад, кольори, форми) без впливу на інші частини зображення.

**_Вбудований SVG_** : це спосіб вставлення векторної графіки безпосередньо в HTML-документ, використовуючи тег <svg>.

Приклад простого вбудованого SVG:

<pre>
<svg width="100" height="100">
   <use href="./шлях-до-svg-спрайту/имʼя-спрайта.svg#ідентифікатор-символа"></use>
</svg>
</pre>

<svg>: Основний контейнер для елементів SVG. Атрибути width і height визначають розміри SVG.

_Властивість fill_ керує кольором заливки. Колір можна задавати у будь-якому зручному форматі.

Проте цей підхід має низку обмежень.

1. Вбудований SVG-код збільшує розмір файлу HTML.
2. Неможливо повторно використовувати те саме зображення без дублювання коду.
3. Підтримка та виправлення вбудованого SVG трудомісткі, доведеться шукати його в HTML коді.
4. Браузер не може кешувати такі зображення, на відміну від зовнішніх файлів SVG.

**_SVG-спрайт_** : це техніка, що дозволяє зберігати кілька векторних графічних зображень (SVG) в одному файлі, що зменшує кількість HTTP-запитів і покращує продуктивність веб-сторінки. Замість того, щоб завантажувати кілька окремих SVG-файлів, усі іконки або графіки зберігаються в одному спрайті, і ви можете звертатися до них за допомогою елементів <svg> i <use>.

<svg>
  <use href="./шлях-до-svg-спрайту/имʼя-спрайта.svg#ідентифікатор-символа"></use>
</svg>

**_Основні переваги SVG-спрайтів_**

1. Зменшення запитів: Завантажуючи один файл замість кількох, ви зменшуєте кількість HTTP-запитів, що покращує швидкість завантаження сторінки.

2. Швидкість: SVG-спрайти можуть збільшити швидкість завантаження, особливо якщо на сторінці використовується багато графіки.

3. Масштабованість: Як і звичайні SVG, спрайти зберігають високу якість при зміні розміру.

**Псевдоелементи**
**_Псевдоелементи ::before ::after_** :За замовчуванням псевдоелементи — це рядкові елементи. Для того, щоб задати псевдоелементу вертикальну геометрію, необхідно змінити його тип на блоковий або рядково-блоковий.

::before - створює псевдоелемент перед всім вмістом елемента (на початку).
::after - створює псевдоелемент після всього вмісту елемента (наприкінці).

**_Властивість content_** : дозволяє додати текстовий контент всередину псевдоелемента. Ця властивість є обов’язковою, без неї браузер просто не створить псевдоелемент. Якщо за макетом текстовий контент не потрібний, його значенням необхідно поставити порожній рядок.

**_Псевдоклас :hover_** : використовується для застосування стилів до елемента, коли на нього наводять курсор миші.

**Позиціоновані елементи**
**_Властивість position_** :у CSS визначає, як елемент буде позиціонуватися на веб-сторінці. Вона є ключовою для управління розміщенням елементів, а також для створення складних макетів.

position: static | relative | absolute | fixed | sticky

1. static
   Опис: Це значення за замовчуванням. Елементи позиціонуються відповідно до нормального потоку документа.
   Вплив: Властивості top, right, bottom, left не впливають на позицію елемента.

2. relative
   Опис: Елемент позиціонується відносно свого нормального положення.
   Вплив: Властивості top, right, bottom, left зміщують елемент від його стандартного місця, але не впливають на позицію сусідніх елементів.

3. absolute
   Опис: Елемент позиціонується відносно найближчого батьківського елемента, у якого задано позиціонування, відмінне від static. Якщо такого елемента немає, позиціонується відносно вікна браузера.
   Вплив: Властивості top, right, bottom, left повністю контролюють позицію елемента.

4. fixed
   Опис: Елемент позиціонується відносно вікна браузера і залишається на місці під час прокрутки.
   Вплив: Властивості top, right, bottom, left задають позицію елемента відносно країв вікна.

5. sticky
   Опис: Елемент веде себе як relative, поки не досягне певної позиції, після чого стає fixed.
   Вплив: Це дозволяє елементу залишатися на видимій частині екрана під час прокрутки.

**_Властивість z-index_** : у CSS використовується для визначення порядку накладання елементів на сторінці, тобто яка частина елемента повинна бути поверх інших. z-index працює лише для позиціонованих елементів, тобто тих, у яких задано значення position, відмінне від static (наприклад, relative, absolute, fixed, або sticky).

Основні характеристики z-index:

1. Числове значення: z-index приймає ціле число, яке визначає порядок накладання. Вищі значення означають, що елемент буде розташований поверх елементів з нижчими значеннями.

2. Контекст накладання: z-index створює новий контекст накладання, якщо застосовується до елемента з позиціонуванням. Це означає, що z-index вплине тільки на дочірні елементи в межах цього контексту.

3. Від'ємні значення: z-index може також мати від'ємні значення. Елементи з від'ємним z-index будуть знаходитися під елементами з нульовим або позитивним z-index.

**CSS-переходи** : дозволяють створювати плавні анімаційні ефекти при зміні властивостей елементів. Це допомагає поліпшити візуальне сприйняття інтерфейсу, роблячи взаємодію з користувачем більш приємною.

Перехід завжди має тільки два стани: 1) початкове і 2) кінцеве значення властивості, і вміє змінювати це значення A > B і B > A за вказаний час.

! Для анімацій, де кількість станів перевищує 2, необхідно використовувати анімацію CSS.

Основні характеристики CSS-переходів:

1. Плавність: Переходи дозволяють плавно змінювати властивості, такі як колір, розмір, позиція та інші, протягом заданого часу.

2. Визначення тривалості: Можна вказати, скільки часу триватиме перехід.

3. Функція часу: Можна задати, як швидкість зміни властивостей змінюється з часом (linear, ease, ease-in, ease-out, ease-in-out тощо).

4. Цільові властивості: Переходи можна застосовувати до конкретних властивостей або до всіх властивостей одночасно.

Властивості які керують різними параметрами переходу:

1. transition-property: <властивість> (Значенням може бути одна властивість або список властивостей через кому.)
2. transition-duration: <час> (Значення властивості вказується в: секундах: 2s або 0.5s мілісекундах: 2000ms або 500ms)
3. transition-timing-function: <функція розподілу часу тобто поведінка анімації>
   Ключові слова:
   ease — перехід починається повільно, швидко прискорюється, а потім знову сповільнюється в кінці.За замовчуванням використовується
   linear — перехід має рівномірну швидкість.
   ease-in — починається повільно, швидкість переходу збільшується до повного завершення переходу.
   ease-out — починається швидко, уповільнюється протягом переходу.
   ease-in-out — починається повільно, прискорюється, а потім знову сповільнюється.
4. transition-delay: <затримка> (Значення властивості вказується в: секундах: 2s або 0.5s мілісекундах: 2000ms або 500ms)

**_Всі властивості переходу можна поєднати в одну складову властивість transition._**

transition: [property] [duration] [timing-function] [delay]

Якщо анімується кілька властивостей, то набір значень кожної з них розділяється комою.
Необхідно обов'язково вказати властивість та час переходу.
Функцію часу та затримку можна не вказувати — тоді для них буде використано значення за замовчуванням.

**2D-трансформації**
**_Масштабування_**
2D-трансформації в CSS дозволяють змінювати вигляд елементів у двох вимірах (ширина та висота). Однією з найбільш поширених 2D-трансформацій є масштабування (scaling), яке дозволяє змінювати розміри елемента.

**_Властивість transform_** :Для застосування масштрабування до елемента використовується властивість transform з функцією scale()

Функції:
transform: scale(sx, sy);
масштабують блок по ширині та/або висоті, не впливаючи на геометрію навколишніх елементів. Якщо для scale() задано певне значення, друге буде таким самим.

**_Поворот_**
Функція rotate(кут) повертає елементи на задану кількість градусів (одиниця deg). Позитивні значення повертають елемент за годинниковою стрілкою, негативні — проти.
Значення можна передати не лише в градусах, а й в «обертах» (одиниця turn).

**_Зміщення_**
Функції translateX(tx), translateY(ty) і translate(tx, ty) переміщають елемент у
горизонтальному (вісь X) та/або вертикальному (вісь Y) напрямках щодо початкового положення.

Позитивні значення X зміщують елемент праворуч, негативні — ліворуч.
Позитивні значення Y зміщують елемент вниз, негативні — вгору.

Значення можуть бути у пікселях чи відсотках. Якщо значення задано у відсотках, воно розраховується від розміру зміщуваного елемента.

**_Декоративний оверлей_**
Зміщення та властивість overflow зі значенням hidden використовуються при створенні декоративних ефектів з появою прихованого вмісту з-за меж блоку.

Такий ефект реалізується за кілька простих кроків. Розберемо стилі для створення ефекту. Повний код дивись у живому прикладі.

<div class="box">
  <div class="overlay"></div>
</div>

1. Спочатку абсолютно позиціонуємо div.overlay відносно div.box і розтягуємо його на всю ширину і висоту div.box.

.box {
position: relative;
}

.overlay {
position: absolute;
top: 0;
left: 0;
width: 100%;
height: 100%;
}

2. Використовуючи властивість transform і translateX, зміщуємо div.overlay ліворуч на 100% його ширини.

.overlay {
position: absolute;
top: 0;
left: 0;
width: 100%;
height: 100%;

transform: translateX(-100%);
}

3. При ховері по div.box, використовуючи transform і translateX, повертаємо div.overlay у вихідне положення.

.box:hover .overlay {
transform: translateX(0);
}

4. Задаємо div.box властивість overflow зі значенням hidden, щоб візуально сховати div.overlay при зміщенні за межі div.box.

.box {
position: relative;
overflow: hidden;
}

5. Додаємо div.overlay перехід для анімації властивості transform, тим самим анімуємо появу оверлею.

.overlay {
position: absolute;
top: 0;
left: 0;
width: 100%;
height: 100%;

transform: translateX(-100%);
transition: transform 250ms ease-in-out;
}

**_Центрування елемента_** : прийом, що дозволяє розташувати абсолютно позиціонований елемент точно по центру блока, відносно якого він позиціонується.

<div class="parent">
  <div class="box"></div>
</div>

Техніка дуже проста і складається із трьох кроків:

1. Абсолютно позиціонуємо елемент відносно предка.
2. Задаємо елементу властивості top і left зі значенням 50%, щоб розташувати верхній лівий кут елемента рівно по центру предка.
3. Задаємо елементу негативне зміщення (translate) по 50% висоти і ширини. Це змістить елемент вгору і вліво і відцентрує всередині предка.

.parent {
position: relative;
}

.box {
position: absolute;
top: 50%;
left: 50%;
transform: translate(-50%, -50%);
}

**_Викривлення_**

Функції skewX(кут), skewY(кут) і skew(x-кут, y-кут) використовуються для визначення параметрів викривлення (нахилу, деформування) сторін елемента відносно координатних осей. Якщо для skew() вказано тільки одне значення, друге буде дорівнювати 0, тобто це буде аналог skewX().

# goit-markup-hw-05

**Форми**

**_HTML-форма_**

**_Елемент form_** : використовується для збору даних від користувача. Це основа для створення інтерактивних веб-форм, які дозволяють користувачам вводити інформацію, таку як текст, вибір з меню, перевірка параметрів і так далі. Форми можуть включати різні типи елементів для введення даних, а також кнопки для їх відправки.

**_Основні атрибути елемента <form>_**

1. action: Визначає URL, куди буде надіслане дані форми при її відправці.
2. method: Визначає метод HTTP, який буде використовуватися для відправки даних. Найбільш поширені значення:
   GET: Дані відправляються через URL (підходить для запитів, що не змінюють дані).
   POST: Дані відправляються в тілі запиту (підходить для форм, що змінюють дані).
3. enctype: Визначає тип кодування, який буде використовуватися при відправці даних. Зазвичай використовується з методом POST. Приклад:
   application/x-www-form-urlencoded: Стандартне кодування.
   multipart/form-data: Використовується для відправки файлів.
   text/plain: Відправка даних у простому текстовому форматі.
4. name: Дозволяє ідентифікувати форму, що може бути корисно при обробці даних на сервері.
5. target: Визначає, де буде відкритий результат після відправки форми (наприклад, у новій вкладці).

**_Основні елементи форми_**

1. <input>: Основний елемент для вводу даних. Може мати різні типи, такі як text, password, checkbox, radio, file, тощо. (За замовчуванням поле введення є рядковим елементом, який не успадковує сімейство шрифтів.Отже, до глобальних стилів можна додати правило для всіх полів вводу.)
   <input type="text" name="username" placeholder="Enter your username">
   (Атрибут **placeholder** дозволяє відображати текст-підказку про дані, які необхідно ввести в поле.)

   (Атрибут **autofocus** -За наявності цього атрибута, поле вводу автоматично отримує фокус при завантаженні. Отже, в ньому відразу можна буде набирати текст. За замовчуванням цього атрибута немає в жодному полі.)

   (Псевдоелемент **::placeholder** - оформлення тексту підказки )

   (Псевдоклас **:placeholder-shown** застосовується залежно від видимості тексту-підказки та значення атрибута placeholder.Він дозволяє налаштовувати властивості поля вводу під час відображення тексту-підказки.)

   (Псевдоклас **:focus-within** - Застосовується до елемента, щойно він сам або елементи всередині нього отримують фокус. Це дозволяє застосувати стилі на:
   мітку
   форму
   окреме поле форми
   при взаємодії користувача з полями форми.
   )

2. <textarea>: Для вводу багаторядкового тексту.
   <textarea name="message" rows="4" cols="50"></textarea>
   **rows** — встановлює кількість рядків (висоту)
   **cols** — встановлює кількість колонок (ширину)
   ((За замовчуванням елемент textarea можна розтягувати по горизонталі і вертикалі. Для того щоб контролювати можливість зміни розміру користувачем, CSS має властивість resize.
   **resize: both | horizontal | vertical | none**
   ))

3. <select>: Дропдаун для вибору з кількох варіантів.
   <select name="options">
   <option value="option1">Option 1</option>
   <option value="option2">Option 2</option>
   </select>
   (Якщо потрібно згрупувати опції випадаючого меню, використовується тег __optgroup__.)

4. <button>: Кнопка для відправки форми або виконання дії.
   <button type="submit">Submit</button>

5. <label>: Мітка для елементів форми, що полегшує взаємодію з формами.
   <label for="username">Username:</label>
   <input type="text" id="username" name="username">

**Специфічна інформація у формах**

**_Поле вводу пошти_**
Значення атрибута _type_ визначає тип поля і набір символів, які в нього можна ввести.
<input type="email" name="email" />

**_Поле вводу пароля_**
Для типу password значення пароля, який вводить користувач, буде візуально замінено на маркери з міркувань безпеки.
<input type="password" name="pwd" minlength="5" maxlength="12" />

Атрибути **minLength і maxLength** не обов'язкові. Вони дозволяють обмежити кількість символів, які можна ввести в поле.

**_Телефонні номери_**
Атрибут type має також значення tel, що створює поле вводу телефонних номерів.
<input type="tel" name="phone" />

На практиці користь від застосування поля типу tel полягає у відображенні віртуальної клавіатури для введення телефонних номерів у мобільних браузерах, що містить цифри, але не літери.

**_Числа_**
Звичайні текстові поля приймають буквально все: цифри, літери, пробіли, знаки пунктуації тощо. Для того щоб дозволити вводити тільки цифри, використовується тип поля number. При введенні даних у числове поле браузер ігнорує все, окрім цифр.
<input type="number" name="age" value="0" min="18" max="120" step="0.5"/>
За допомогою атрибутів min і max - визначають діапазон введення.
За замовчуванням числові поля приймають лише цілі числа.
Цю поведінку можна змінити за допомогою атрибута step. Цей атрибут вказує крок зміни числа. За замовчуванням значення кроку дорівнює 1.

**_Дата та час_**
Поле вводу також може бути використане для вибору дати та/або часу. Для цього йому необхідно задати один із типів **date**, **time** або **datetime-local**.

<!-- Для вибору лише дати -->
<input type="date" />
<!-- Для вибору лише часу-->
<input type="time" />
<!-- Для вибору дати і часу -->
<input type="datetime-local" />

**Елементи радіокнопка і чекбокс**
**_Радіокнопки_**
Додавання атрибута type зі значенням radio перетворює поле вводу на перемикач (радіокнопку, radio button).

<form>
  <p>Choose a color:</p>
  <label>
    <input type="radio" name="color" value="red" checked />
    Red
  </label>
  <label>
    <input type="radio" name="color" value="white" />
    White
  </label>
  <label>
    <input type="radio" name="color" value="green" />
    Green
  </label>
</form>
Кожній радіокнопці в групі задається однакове значення атрибута name, інакше браузер не знатиме, що це група.
У радіокнопки не можна вводити дані. Тому кожній з них необхідно вказати значення в атрибуті value. Це значення, яке буде передано на сервер, коли користувач відправить форму.
Атрибут checked вказує, який перемикач буде обраний (позначений) за замовчуванням. У групі радіокнопок в стані checked може бути тільки один елемент. За замовчуванням перший.

**_Чекбокси_**
Прапорці (чекбокси, checkbox) схожі на перемикачі, але дозволяють вибирати довільну кількість значень, тобто багато з багатьох.
Чекбокс може використовуватися:
окремо, наприклад, прийняття користувальницької угоди при реєстрації.
у групі, наприклад, вибір хобі.
Кожному чекбоксу в групі задається однакове значення атрибута name, інакше браузер не знатиме, що це група.
У чекбокси не можна вводити дані, тому кожному з них необхідно вказати значення в атрибуті value.
Атрибут checked вказує, який чекбокс буде обраний за замовчуванням. У групі чекбоксів в стані checked може бути скільки завгодно елементів. За замовчуванням немає жодного.

**Псевдоклас :checked**
Псевдоклас :checked застосовується до:
радіокнопок
чекбоксів
опцій випадаючого меню в селектах
Він дозволяє додати стилі тільки до зазначених полів (інтерактивів).

Селектор **input:checked** застосовується до всіх можливих полів.
Для того щоб стилізувати тільки чек-бокси форми, але не задавати клас кожному полю вводу, можна використовувати селектор атрибута.
input[type="checkbox"] {
}
Псевдоклас :checked може використовуватися для стилізації вибраних елементів.
Для цього потрібно використовувати **селектор X + Y**. Цей селектор вибирає тільки той елемент Y, який в HTML-розмітці слідує відразу ж за X.

ul + p {
background-color: yellow;
}
У цьому CSS правилі ми виберемо тільки той абзац тексту, що розташований після ненумерованого списку

**_Обов'язкові поля_**

атрибут **required** позначає поле форми як обов'язкове для заповнення.
<input type="email" name="email" required />

Атрибут **disabled** дозволяє зробити інтерактивний елемент неактивним. Такі елементи не отримують ефекту фокусу, а також ігнорують кліки миші.
<button type="button" disabled>Disabled button</button>

**_Групування полів_**

Елемент **fieldset** — це контейнер для групування декількох пов'язаних елементів у формі, а вкладений **legend** виконує роль заголовка групи. Пов'язані радіокнопки та чек-бокси завжди повинні бути згруповані. Інші типи полів групуються за потребою.
За замовчуванням елемент fieldset має маржини, падінги і рамку. Їх можна скинути глобально або точково для певної форми, залежить від завдання.

**Створення модального вікна**
